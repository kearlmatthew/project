<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Prevent double tap zoom on mobile */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
    // --- Configuration ---
    const CANVAS_ID = 'gameCanvas';
    const BIRD_COLOR = '#FFD700'; // Gold/Yellow
    const BIRD_STROKE = '#000000';
    const SKY_COLOR = '#70c5ce';
    const PIPE_COLOR = '#73bf2e';
    const PIPE_STROKE = '#558c22';
    
    // Physics constants
    const GRAVITY = 0.25;
    const JUMP_STRENGTH = -5.5;
    const PIPE_SPEED = 3;
    const PIPE_SPAWN_RATE = 100; // Frames between pipes
    const FEET_PER_SECOND = 8;

    // --- Game State ---
    const canvas = document.getElementById(CANVAS_ID);
    const ctx = canvas.getContext('2d');
    
    let frames = 0;
    let gameState = 'START'; // START, PLAYING, GAMEOVER
    let startTime = 0;
    let endTime = 0;
    let finalDistance = 0;
    let finalTime = 0;

    // Cheat Mode State
    let isCheating = false;

    // Resize handling
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- Input Handling ---

    // Cheat Key Listeners
    window.addEventListener('keydown', (e) => {
        if (e.code === 'KeyA') isCheating = true;
    });
    window.addEventListener('keyup', (e) => {
        if (e.code === 'KeyA') isCheating = false;
    });

    function handleInput(e) {
        if (e.type === 'keydown' && e.code !== 'Space') return;
        if (e.type === 'touchstart') e.preventDefault(); // Prevent scroll

        switch (gameState) {
            case 'START':
                resetGame();
                gameState = 'PLAYING';
                startTime = Date.now();
                bird.flap();
                break;
            case 'PLAYING':
                bird.flap();
                break;
            case 'GAMEOVER':
                // Optional: Restart on click after death
                gameState = 'START';
                resetGame();
                break;
        }
    }

    window.addEventListener('keydown', handleInput);
    window.addEventListener('touchstart', handleInput, { passive: false });
    window.addEventListener('mousedown', handleInput);

    // --- Game Objects ---

    const bird = {
        x: 50,
        y: 150,
        radius: 15,
        velocity: 0,
        rotation: 0,
        
        draw: function() {
            ctx.save();
            ctx.translate(this.x, this.y);
            // Rotation based on velocity
            this.rotation = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
            ctx.rotate(this.rotation);

            // Body
            ctx.fillStyle = BIRD_COLOR;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = BIRD_STROKE;
            ctx.stroke();

            // Eye
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(6, -6, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Pupil
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(8, -6, 2, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#FFA500'; // Orange
            ctx.beginPath();
            ctx.moveTo(8, 2);
            ctx.lineTo(18, 6);
            ctx.lineTo(8, 10);
            ctx.fill();
            ctx.stroke();

            // Wing
            ctx.fillStyle = '#F0E68C'; // Khaki
            ctx.beginPath();
            ctx.ellipse(-6, 4, 8, 5, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
        },
        
        update: function() {
            this.velocity += GRAVITY;
            this.y += this.velocity;

            // Floor collision
            if (this.y + this.radius >= canvas.height) {
                this.y = canvas.height - this.radius;
                gameOver();
            }
            
            // Ceiling collision check (optional, but good for gameplay)
            if (this.y - this.radius <= 0) {
                this.y = this.radius;
                this.velocity = 0;
            }
        },
        
        flap: function() {
            this.velocity = JUMP_STRENGTH;
        }
    };

    const pipes = {
        items: [],
        
        reset: function() {
            this.items = [];
        },

        update: function() {
            // Add new pipe
            if (frames % PIPE_SPAWN_RATE === 0) {
                // Gap size
                const gap = 170; 
                // Random position for the gap
                const minPipeHeight = 50;
                const maxPipeHeight = canvas.height - gap - minPipeHeight;
                const topHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1) + minPipeHeight);

                this.items.push({
                    x: canvas.width,
                    y: topHeight, // This is the bottom of the top pipe
                    width: 60,
                    gap: gap
                });
            }

            // Move and remove pipes
            for (let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                p.x -= PIPE_SPEED;

                // Collision Detection
                // AABB (Axis-Aligned Bounding Box) logic adjusted for Circle bird
                // Check X overlap
                if (bird.x + bird.radius > p.x && bird.x - bird.radius < p.x + p.width) {
                    // Check Y overlap (Top pipe or Bottom pipe)
                    // Top pipe: from 0 to p.y
                    // Bottom pipe: from p.y + p.gap to canvas.height
                    if (bird.y - bird.radius < p.y || bird.y + bird.radius > p.y + p.gap) {
                        gameOver();
                    }
                }

                // Remove off-screen pipes
                if (p.x + p.width < 0) {
                    this.items.shift();
                    i--;
                }
            }
        },

        draw: function() {
            for (let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                
                ctx.fillStyle = PIPE_COLOR;
                ctx.strokeStyle = PIPE_STROKE;
                ctx.lineWidth = 3;

                // Top Pipe
                ctx.fillRect(p.x, 0, p.width, p.y);
                ctx.strokeRect(p.x, 0, p.width, p.y);
                
                // Bottom Pipe
                const bottomPipeY = p.y + p.gap;
                const bottomPipeHeight = canvas.height - bottomPipeY;
                ctx.fillRect(p.x, bottomPipeY, p.width, bottomPipeHeight);
                ctx.strokeRect(p.x, bottomPipeY, p.width, bottomPipeHeight);

                // Pipe Caps (The rectangular wider parts)
                const capHeight = 25;
                const capOverflow = 4;

                // Top Cap
                ctx.fillRect(p.x - capOverflow, p.y - capHeight, p.width + (capOverflow*2), capHeight);
                ctx.strokeRect(p.x - capOverflow, p.y - capHeight, p.width + (capOverflow*2), capHeight);

                // Bottom Cap
                ctx.fillRect(p.x - capOverflow, bottomPipeY, p.width + (capOverflow*2), capHeight);
                ctx.strokeRect(p.x - capOverflow, bottomPipeY, p.width + (capOverflow*2), capHeight);
            }
        }
    };

    const clouds = {
        items: [],
        
        reset: function() {
            this.items = [];
            // Pre-populate a few clouds
            for(let i=0; i<5; i++) {
                this.spawn(Math.random() * canvas.width);
            }
        },

        spawn: function(startX) {
            this.items.push({
                x: startX || canvas.width,
                y: Math.random() * (canvas.height / 2), // Top half only
                size: 30 + Math.random() * 40,
                speed: 0.5 + Math.random() * 0.5 // Slower than pipes
            });
        },

        update: function() {
            if (frames % 200 === 0) {
                this.spawn();
            }

            for (let i = 0; i < this.items.length; i++) {
                let c = this.items[i];
                c.x -= c.speed;
                if (c.x + c.size * 3 < 0) { // Check if fully off screen
                    this.items.shift();
                    i--;
                }
            }
        },

        draw: function() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < this.items.length; i++) {
                let c = this.items[i];
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
                ctx.arc(c.x + c.size * 0.5, c.y - c.size * 0.4, c.size * 0.8, 0, Math.PI * 2);
                ctx.arc(c.x + c.size, c.y, c.size * 0.9, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    };

    // --- Game Logic functions ---

    function resetGame() {
        bird.x = canvas.width / 4; // Start position
        bird.y = canvas.height / 2;
        bird.velocity = 0;
        bird.rotation = 0;
        pipes.reset();
        clouds.reset();
        frames = 0;
    }

    function gameOver() {
        if(gameState === 'GAMEOVER') return; // Prevent double trigger
        
        gameState = 'GAMEOVER';
        endTime = Date.now();
        
        // Calculate stats
        let timeInSeconds = (endTime - startTime) / 1000;
        finalTime = timeInSeconds.toFixed(2);
        finalDistance = (timeInSeconds * FEET_PER_SECOND).toFixed(2);
    }

    function drawUI() {
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.textAlign = 'center';

        if (gameState === 'START') {
            ctx.font = 'bold 30px "Segoe UI", sans-serif';
            ctx.strokeText("Press space to start flying!", canvas.width / 2, canvas.height / 2);
            ctx.fillText("Press space to start flying!", canvas.width / 2, canvas.height / 2);
        } else if (gameState === 'PLAYING') {
            // Optional: Show live score or distance
            let currentSeconds = (Date.now() - startTime) / 1000;
            let currentDist = Math.floor(currentSeconds * FEET_PER_SECOND);
            
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'left';
            ctx.fillText(`Distance: ${currentDist} ft`, 20, 40);
        } else if (gameState === 'GAMEOVER') {
            // Draw semi-transparent background box
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(canvas.width/2 - 250, canvas.height/2 - 100, 500, 200);

            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            
            ctx.font = 'bold 40px "Segoe UI", sans-serif';
            ctx.fillText("Uh Oh! You died.", canvas.width / 2, canvas.height / 2 - 20);
            
            ctx.font = '30px "Segoe UI", sans-serif';
            ctx.fillText(`Time: ${finalTime}s Distance: ${finalDistance}ft`, canvas.width / 2, canvas.height / 2 + 40);

            ctx.font = '20px "Segoe UI", sans-serif';
            ctx.fillStyle = '#ddd';
            ctx.fillText("(Press space or tap to retry)", canvas.width / 2, canvas.height / 2 + 80);
        }
    }

    // --- Main Game Loop ---
    function loop() {
        // Clear screen
        ctx.fillStyle = SKY_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Update & Draw Background
        clouds.update(); // Clouds move always for ambience
        clouds.draw();

        if (gameState === 'PLAYING') {
            // Cheat / Auto-Pilot Logic
            if (isCheating) {
                // Find the closest relevant pipe (one that is in front of or overlapping the bird)
                const nextPipe = pipes.items.find(p => p.x + p.width > bird.x - bird.radius);
                
                let targetY = canvas.height / 2; // Default to center if no pipes
                if (nextPipe) {
                    // Target the center of the gap
                    targetY = nextPipe.y + (nextPipe.gap / 2);
                }

                // If bird is below the target and not currently moving up rapidly, flap
                if (bird.y > targetY + 10 && bird.velocity >= 0) {
                    bird.flap();
                }
            }

            pipes.update();
            bird.update();
            frames++;
        }

        // Draw Game Objects
        pipes.draw();
        bird.draw();

        // UI
        drawUI();
        
        // Cheat Indicator
        if (isCheating && gameState === 'PLAYING') {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'right';
            ctx.fillText("AUTOPILOT ON", canvas.width - 20, 30);
        }

        requestAnimationFrame(loop);
    }

    // Start
    clouds.reset(); // Init clouds
    loop();

</script>
</body>
</html>