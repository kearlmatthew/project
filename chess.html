<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Chess Battle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for captured pieces if needed */
        .captured-area::-webkit-scrollbar {
            height: 4px;
        }
        .captured-area::-webkit-scrollbar-thumb {
            background-color: #a8a29e;
            border-radius: 2px;
        }
        
        /* Board square colors */
        .square-light { background-color: #f0d9b5; }
        .square-dark { background-color: #b58863; }
        
        /* Highlights */
        .square-selected { background-color: #829769 !important; }
        .square-last-move { background-color: #cdd26a !important; }
        .square-valid-move::after {
            content: '';
            position: absolute;
            width: 20%;
            height: 20%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            top: 40%;
            left: 40%;
        }
        .square-capture::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            border: 4px solid rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            top: 10%;
            left: 10%;
        }

        .piece {
            cursor: pointer;
            transition: transform 0.1s;
            /* Ensure SVG pieces are sharp and fill their container */
            width: 90%; 
            height: 90%;
        }
        .piece:active {
            transform: scale(1.1);
        }

        /* Modal transition */
        .modal {
            transition: opacity 0.3s ease-in-out;
        }
        .hidden-modal {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-stone-900 text-stone-100 font-sans h-screen flex flex-col overflow-hidden select-none">

    <!-- Top Bar -->
    <div class="h-16 bg-stone-800 flex items-center justify-between px-4 shadow-lg z-10">
        <div class="flex items-center gap-2">
            <span class="text-xl font-bold text-amber-500">Ultimate Chess</span>
        </div>
        
        <div class="flex items-center gap-6">
            <div class="text-center">
                <div class="text-xs text-stone-400">TURN</div>
                <div id="turn-indicator" class="font-bold text-white">White</div>
            </div>
            <div class="text-center">
                <div class="text-xs text-stone-400">TIME</div>
                <div id="game-timer" class="font-mono text-xl">00:00</div>
            </div>
        </div>

        <button id="pause-btn" class="bg-stone-700 hover:bg-stone-600 px-4 py-2 rounded text-sm font-semibold transition">
            Pause
        </button>
    </div>

    <!-- Main Game Area -->
    <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">
        
        <!-- Left Sidebar: Black Captured (White's trophies) -->
        <div class="lg:w-64 bg-stone-800/50 p-4 flex flex-col border-r border-stone-700">
            <h3 class="text-stone-400 text-xs font-bold mb-2 uppercase">Captured by White</h3>
            <div id="captured-black" class="captured-area flex flex-wrap gap-2 content-start overflow-y-auto"></div>
        </div>

        <!-- Center: Board (Now with fixed max size and aspect-square) -->
        <div class="flex-1 flex items-center justify-center bg-stone-900 p-4 relative">
            
            <!-- Board Container - max-w-[560px] enforces the fixed proportional size -->
            <div id="board" class="grid grid-cols-8 gap-0 border-4 border-stone-700 shadow-2xl relative w-full max-w-[560px] aspect-square">
                <!-- Squares generated by JS -->
            </div>

        </div>

        <!-- Right Sidebar: White Captured (Black's trophies) -->
        <div class="lg:w-64 bg-stone-800/50 p-4 flex flex-col border-l border-stone-700">
            <h3 class="text-stone-400 text-xs font-bold mb-2 uppercase">Captured by Black</h3>
            <div id="captured-white" class="captured-area flex flex-wrap gap-2 content-start overflow-y-auto"></div>
        </div>

    </div>

    <!-- Modal: Start / Pause / Game Over -->
    <div id="game-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center">
        <div class="bg-stone-800 border border-stone-600 p-8 rounded-xl shadow-2xl max-w-md w-full text-center">
            
            <h1 id="modal-title" class="text-3xl font-bold text-amber-500 mb-2">Ultimate Chess Battle</h1>
            <p id="modal-subtitle" class="text-stone-400 mb-6">Prepare for battle</p>

            <!-- Difficulty Slider -->
            <div class="mb-8">
                <label class="block text-left text-sm font-semibold text-stone-300 mb-2">
                    Opponent Difficulty: <span id="difficulty-value" class="text-amber-400">5</span>
                </label>
                <input type="range" id="difficulty-slider" min="1" max="10" value="5" 
                       class="w-full h-2 bg-stone-600 rounded-lg appearance-none cursor-pointer accent-amber-500">
                <div class="flex justify-between text-xs text-stone-500 mt-1">
                    <span>Easy</span>
                    <span>Hard</span>
                    <span>Impossible</span>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-3">
                <button id="resume-btn" class="bg-emerald-600 hover:bg-emerald-500 text-white py-3 rounded-lg font-bold shadow-lg transition hidden">
                    Resume Game
                </button>
                <button id="start-btn" class="bg-amber-600 hover:bg-amber-500 text-white py-3 rounded-lg font-bold shadow-lg transition">
                    Start New Game
                </button>
                <button id="cancel-btn" class="bg-stone-700 hover:bg-stone-600 text-stone-300 py-3 rounded-lg font-semibold transition hidden">
                    Cancel Game
                </button>
            </div>

        </div>
    </div>

    <!-- Notification Toast -->
    <div id="toast" class="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-stone-800 text-white px-6 py-3 rounded-full shadow-xl translate-y-20 transition-transform duration-300 pointer-events-none z-50 border border-amber-500/50">
        Notification
    </div>

    <script>
        // --- ASSETS (SVGs) ---
        const PIECES = {
            w: {
                k: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#fff" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-5 2-8 2s-4-1-9-1-5 0-9 1-4-3-8-2c-3 6 6 10.5 6 10.5v7V37z" fill="#fff" stroke-linecap="butt"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/></g></svg>',
                q: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM10.5 20a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM38.5 20a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14.5V25L7 14l2 12z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 2.5 1.5 4.5 1.5 4.5l1 1.5c1.5 2.5 6.5 2.5 8 0 1.5-2.5 6.5-2.5 8 0 1.5 2.5 6.5 2.5 8 0l1-1.5c0 0 .5-2 1.5-4.5 1-2 2.5-2 2.5-4H9zM11 30.5c5.5-1.5 15.5-1.5 21 0m-21 3.5c5.5-1.5 15.5-1.5 21 0m-21 3.5c5.5-1.5 15.5-1.5 21 0"/></g></svg>',
                r: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5c1 2 2 5 2 6.5H12c0-1.5 1-4.5 2-6.5V17H31z" stroke-linecap="butt"/><path d="M31 29.5c3.5-1 7-1 10 1 .5 2 1.5 4.5 1.5 4.5H2c0 0 1-2.5 1.5-4.5 3-2 6.5-2 10-1"/><path d="M11 14h23" fill="none" stroke-linejoin="miter"/></g></svg>',
                b: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#fff" stroke-linecap="butt"><path d="M9 36c3.39-.97 9.11-1.45 13.5-1.45 4.38 0 10.11.48 13.5 1.45V30c0-3.9-3.41-7.05-7.61-7.05-4.2 0-7.61 3.15-7.61 7.05V36z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke-linejoin="miter"/></g></svg>',
                n: '<svg viewBox="0 0 45 45"><g fill="#fff" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" stroke-linecap="butt"/><path d="M24 18c.38 2.32-2.58 2.9-3 3l-1.53 3c2.85 1.63 7.55 3.32 10.57-2.67A9.33 9.33 0 0 0 32.5 15a7.1 7.1 0 0 0-3.23-5.26C28.2 9.07 26 9.42 25 10c-1.25.72-3.13 1.95-3 4 .13 1.93 1.48 3.52 2 4z" stroke-linecap="butt"/><path d="M9.5 25.5A4.5 4.5 0 1 1 5 21a4.5 4.5 0 0 1 4.5 4.5zM15 15.5a4.5 4.5 0 1 1-4.5-4.5 4.5 4.5 0 0 1 4.5 4.5z" stroke-linecap="butt"/><path d="M11 14c2-3.5 6-2 9-.5" fill="none"/></g></svg>',
                p: '<svg viewBox="0 0 45 45"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" stroke-width="1.5" stroke-linecap="round" /></svg>'
            },
            b: {
                k: '<svg viewBox="0 0 45 45"><g fill="none" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22.5 11.63V6M20 8h5" stroke-linejoin="miter"/><path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#000" stroke-linecap="butt" stroke-linejoin="miter"/><path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-1-5 2-8 2s-4-1-9-1-5 0-9 1-4-3-8-2c-3 6 6 10.5 6 10.5v7V37z" fill="#000" stroke-linecap="butt"/><path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#fff"/></g></svg>',
                q: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M8 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM24.5 7.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM10.5 20a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM38.5 20a2 2 0 1 1-4 0 2 2 0 0 1 4 0z"/><path d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14.5V25L7 14l2 12z" stroke-linecap="butt"/><path d="M9 26c0 2 1.5 2 2.5 4 1 2.5 1.5 4.5 1.5 4.5l1 1.5c1.5 2.5 6.5 2.5 8 0 1.5-2.5 6.5-2.5 8 0 1.5 2.5 6.5 2.5 8 0l1-1.5c0 0 .5-2 1.5-4.5 1-2 2.5-2 2.5-4H9zM11 30.5c5.5-1.5 15.5-1.5 21 0m-21 3.5c5.5-1.5 15.5-1.5 21 0m-21 3.5c5.5-1.5 15.5-1.5 21 0" stroke="#fff"/></g></svg>',
                r: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M9 39h27v-3H9v3zM12 36v-4h21v4H12zM11 14V9h4v2h5V9h5v2h5V9h4v5" stroke-linecap="butt"/><path d="M34 14l-3 3H14l-3-3"/><path d="M31 17v12.5c1 2 2 5 2 6.5H12c0-1.5 1-4.5 2-6.5V17H31z" stroke-linecap="butt"/><path d="M31 29.5c3.5-1 7-1 10 1 .5 2 1.5 4.5 1.5 4.5H2c0 0 1-2.5 1.5-4.5 3-2 6.5-2 10-1" stroke="#fff"/><path d="M11 14h23" fill="none" stroke="#fff" stroke-linejoin="miter"/></g></svg>',
                b: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><g fill="#000" stroke-linecap="butt"><path d="M9 36c3.39-.97 9.11-1.45 13.5-1.45 4.38 0 10.11.48 13.5 1.45V30c0-3.9-3.41-7.05-7.61-7.05-4.2 0-7.61 3.15-7.61 7.05V36z"/><path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/><path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/></g><path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" stroke="#fff" stroke-linejoin="miter"/></g></svg>',
                n: '<svg viewBox="0 0 45 45"><g fill="#000" fill-rule="evenodd" stroke="#000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" stroke-linecap="butt"/><path d="M24 18c.38 2.32-2.58 2.9-3 3l-1.53 3c2.85 1.63 7.55 3.32 10.57-2.67A9.33 9.33 0 0 0 32.5 15a7.1 7.1 0 0 0-3.23-5.26C28.2 9.07 26 9.42 25 10c-1.25.72-3.13 1.95-3 4 .13 1.93 1.48 3.52 2 4z" stroke-linecap="butt"/><path d="M9.5 25.5A4.5 4.5 0 1 1 5 21a4.5 4.5 0 0 1 4.5 4.5zM15 15.5a4.5 4.5 0 1 1-4.5-4.5 4.5 4.5 0 0 1 4.5 4.5z" stroke-linecap="butt"/><path d="M11 14c2-3.5 6-2 9-.5" fill="none" stroke="#fff"/></g></svg>',
                p: '<svg viewBox="0 0 45 45"><path d="M22 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-2.78-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#000" stroke-width="1.5" stroke-linecap="round" /></svg>'
            }
        };

        // --- GAME ENGINE ---
        // Board: 64 length array. 
        // Pieces: 'w'/'b' + 'p'/'n'/'b'/'r'/'q'/'k'. Empty is null.
        
        const BOARD_SIZE = 8;
        const INITIAL_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";

        class ChessEngine {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = Array(64).fill(null);
                this.turn = 'w';
                this.castling = { w: { k: true, q: true }, b: { k: true, q: true } };
                this.enPassant = null; // Target square index
                this.halfMoves = 0;
                this.fullMoves = 1;
                this.loadFEN(INITIAL_FEN);
                this.captured = { w: [], b: [] }; // Pieces captured BY white, BY black
                this.history = [];
            }

            loadFEN(fen) {
                const parts = fen.split(' ');
                const rows = parts[0].split('/');
                
                for (let r = 0; r < 8; r++) {
                    let c = 0;
                    for (let char of rows[r]) {
                        if (isNaN(char)) {
                            const color = char === char.toUpperCase() ? 'w' : 'b';
                            const type = char.toLowerCase();
                            this.board[r * 8 + c] = { color, type };
                            c++;
                        } else {
                            c += parseInt(char);
                        }
                    }
                }
                this.turn = parts[1];
            }

            getPiece(idx) {
                return (idx >= 0 && idx < 64) ? this.board[idx] : null;
            }

            isValidSquare(idx) {
                return idx >= 0 && idx < 64;
            }

            // Generate all pseudo-legal moves for a color
            generateMoves(color, checkLegality = true) {
                const moves = [];
                for (let i = 0; i < 64; i++) {
                    const piece = this.board[i];
                    if (piece && piece.color === color) {
                        moves.push(...this.getPieceMoves(i, piece, checkLegality));
                    }
                }
                return moves;
            }

            getPieceMoves(idx, piece, checkLegality) {
                const moves = [];
                const row = Math.floor(idx / 8);
                const col = idx % 8;
                const directions = {
                    'p': [], // Handled separately
                    'n': [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]],
                    'b': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                    'r': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                    'q': [[-1, -1], [-1, 1], [1, -1], [1, 1], [-1, 0], [1, 0], [0, -1], [0, 1]],
                    'k': [[-1, -1], [-1, 1], [1, -1], [1, 1], [-1, 0], [1, 0], [0, -1], [0, 1]]
                };

                if (piece.type === 'p') {
                    const dir = piece.color === 'w' ? -1 : 1;
                    const startRow = piece.color === 'w' ? 6 : 1;

                    // Forward 1
                    const f1 = idx + dir * 8;
                    if (!this.board[f1]) {
                        moves.push({ from: idx, to: f1, type: 'move' });
                        // Forward 2
                        if (row === startRow) {
                            const f2 = idx + dir * 16;
                            if (!this.board[f2]) {
                                moves.push({ from: idx, to: f2, type: 'move' });
                            }
                        }
                    }
                    // Capture
                    const captures = [idx + dir * 8 - 1, idx + dir * 8 + 1];
                    for (let cap of captures) {
                        const capRow = Math.floor(cap / 8);
                        const capCol = cap % 8;
                        // Check boundary wrapping
                        if (Math.abs(capCol - col) > 1) continue;

                        if (this.isValidSquare(cap)) {
                            const target = this.board[cap];
                            if (target && target.color !== piece.color) {
                                moves.push({ from: idx, to: cap, type: 'capture' });
                            } else if (cap === this.enPassant) {
                                moves.push({ from: idx, to: cap, type: 'enpassant' });
                            }
                        }
                    }
                } else {
                    // Sliding pieces (b, r, q) vs Stepping (n, k)
                    const isSliding = ['b', 'r', 'q'].includes(piece.type);
                    
                    for (let d of directions[piece.type]) {
                        let r = row + d[0];
                        let c = col + d[1];
                        
                        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                            const targetIdx = r * 8 + c;
                            const target = this.board[targetIdx];
                            
                            if (!target) {
                                moves.push({ from: idx, to: targetIdx, type: 'move' });
                            } else {
                                if (target.color !== piece.color) {
                                    moves.push({ from: idx, to: targetIdx, type: 'capture' });
                                }
                                break; // Blocked
                            }

                            if (!isSliding) break;
                            r += d[0];
                            c += d[1];
                        }
                    }
                }

                // Castling
                if (piece.type === 'k' && checkLegality) {
                     // Simple check if king/rooks moved is handled in makeMove, 
                     // but here we check squares
                     // This is slightly complex, keeping it simplified for this single-file constraint
                     // We check if squares between K and R are empty and not under attack
                     // (Attack check is part of isLegal)
                     const cProps = this.castling[piece.color];
                     const backRow = piece.color === 'w' ? 7 : 0;
                     if (cProps.k && this.board[backRow*8+5] === null && this.board[backRow*8+6] === null) {
                         moves.push({ from: idx, to: backRow*8+6, type: 'castle-k' });
                     }
                     if (cProps.q && this.board[backRow*8+3] === null && this.board[backRow*8+2] === null && this.board[backRow*8+1] === null) {
                         moves.push({ from: idx, to: backRow*8+2, type: 'castle-q' });
                     }
                }

                if (checkLegality) {
                    return moves.filter(m => this.isLegal(m));
                }
                return moves;
            }

            isLegal(move) {
                // Simulate move
                const savedState = this.saveState();
                this.makeMove(move, false); // false = don't switch turn yet
                
                // Check if own king is attacked
                const kingIdx = this.board.findIndex(p => p && p.type === 'k' && p.color === savedState.turn);
                const inCheck = this.isSquareAttacked(kingIdx, savedState.turn === 'w' ? 'b' : 'w');
                
                this.restoreState(savedState);
                
                // Castling specific checks (cannot castle out of, through, or into check)
                if (!inCheck && (move.type === 'castle-k' || move.type === 'castle-q')) {
                    if (this.isSquareAttacked(kingIdx, savedState.turn === 'w' ? 'b' : 'w')) return false;
                    const mid = (move.from + move.to) / 2;
                    if (this.isSquareAttacked(mid, savedState.turn === 'w' ? 'b' : 'w')) return false;
                    if (this.isSquareAttacked(move.to, savedState.turn === 'w' ? 'b' : 'w')) return false;
                }

                return !inCheck;
            }

            isSquareAttacked(idx, attackerColor) {
                // Generate all pseudo moves for attacker
                // Optimization: Trace rays from square to see if attackers exist
                // This is faster than generating all enemy moves
                
                const row = Math.floor(idx / 8);
                const col = idx % 8;

                // 1. Pawn attacks
                const pDir = attackerColor === 'w' ? 1 : -1; // Attack comes from "below" if white
                if (attackerColor === 'w') {
                     if (row < 7 && col > 0 && this.isPiece(idx+7, 'p', 'w')) return true; // Down-Left (from pov of square)
                     if (row < 7 && col < 7 && this.isPiece(idx+9, 'p', 'w')) return true;
                } else {
                     if (row > 0 && col > 0 && this.isPiece(idx-9, 'p', 'b')) return true;
                     if (row > 0 && col < 7 && this.isPiece(idx-7, 'p', 'b')) return true;
                }

                // 2. Knight attacks
                const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                for (let d of knightMoves) {
                    const r = row + d[0], c = col + d[1];
                    if (r>=0 && r<8 && c>=0 && c<8 && this.isPiece(r*8+c, 'n', attackerColor)) return true;
                }

                // 3. Sliding (B, R, Q) + King
                const dirs = [
                    { d: [-1, -1], t: ['b', 'q', 'k'] }, { d: [-1, 1], t: ['b', 'q', 'k'] },
                    { d: [1, -1], t: ['b', 'q', 'k'] }, { d: [1, 1], t: ['b', 'q', 'k'] }, // Diagonals
                    { d: [-1, 0], t: ['r', 'q', 'k'] }, { d: [1, 0], t: ['r', 'q', 'k'] },
                    { d: [0, -1], t: ['r', 'q', 'k'] }, { d: [0, 1], t: ['r', 'q', 'k'] }  // Orthogonals
                ];

                for (let group of dirs) {
                    let r = row + group.d[0];
                    let c = col + group.d[1];
                    let dist = 1;
                    while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                        const target = this.board[r*8+c];
                        if (target) {
                            if (target.color === attackerColor && group.t.includes(target.type)) {
                                if (target.type === 'k' && dist > 1) break; // King only 1 step
                                return true;
                            }
                            break;
                        }
                        r += group.d[0];
                        c += group.d[1];
                        dist++;
                    }
                }
                return false;
            }

            isPiece(idx, type, color) {
                const p = this.board[idx];
                return p && p.type === type && p.color === color;
            }

            makeMove(move, switchTurn = true) {
                const p = this.board[move.from];
                const captured = this.board[move.to];
                
                // Update Castling Rights
                if (p.type === 'k') {
                    this.castling[p.color].k = false;
                    this.castling[p.color].q = false;
                }
                if (p.type === 'r') {
                    if (move.from % 8 === 0) this.castling[p.color].q = false; // A-file
                    if (move.from % 8 === 7) this.castling[p.color].k = false; // H-file
                }
                // If rook is captured
                if (captured && captured.type === 'r') {
                    if (move.to % 8 === 0) {
                        const side = captured.color;
                        if(Math.floor(move.to/8) === (side==='w'?7:0)) this.castling[side].q = false;
                    }
                    if (move.to % 8 === 7) {
                        const side = captured.color;
                        if(Math.floor(move.to/8) === (side==='w'?7:0)) this.castling[side].k = false;
                    }
                }

                // Move Piece
                this.board[move.to] = p;
                this.board[move.from] = null;

                // Handle En Passant Capture
                if (move.type === 'enpassant') {
                    const dir = p.color === 'w' ? 1 : -1; // capture is behind the move target
                    this.board[move.to + dir * 8] = null; // Remove pawn
                }

                // Handle Castling Move
                if (move.type === 'castle-k') {
                    const rFrom = move.to + 1; // H file
                    const rTo = move.to - 1;   // F file
                    this.board[rTo] = this.board[rFrom];
                    this.board[rFrom] = null;
                }
                if (move.type === 'castle-q') {
                    const rFrom = move.to - 2; // A file
                    const rTo = move.to + 1;   // D file
                    this.board[rTo] = this.board[rFrom];
                    this.board[rFrom] = null;
                }

                // Promotion (Auto Queen)
                if (p.type === 'p' && (Math.floor(move.to/8) === 0 || Math.floor(move.to/8) === 7)) {
                    p.type = 'q';
                }

                // Set En Passant Target
                if (p.type === 'p' && Math.abs(move.to - move.from) === 16) {
                    this.enPassant = (move.to + move.from) / 2;
                } else {
                    this.enPassant = null;
                }

                if (switchTurn) {
                    this.turn = this.turn === 'w' ? 'b' : 'w';
                }
            }

            saveState() {
                return {
                    board: this.board.map(p => p ? {...p} : null),
                    turn: this.turn,
                    castling: JSON.parse(JSON.stringify(this.castling)),
                    enPassant: this.enPassant
                };
            }

            restoreState(state) {
                this.board = state.board;
                this.turn = state.turn;
                this.castling = state.castling;
                this.enPassant = state.enPassant;
            }

            checkStatus() {
                const moves = this.generateMoves(this.turn, true);
                if (moves.length === 0) {
                    const kingIdx = this.board.findIndex(p => p && p.type === 'k' && p.color === this.turn);
                    if (this.isSquareAttacked(kingIdx, this.turn === 'w' ? 'b' : 'w')) {
                        return 'checkmate';
                    }
                    return 'stalemate';
                }
                return 'playing';
            }
        }

        // --- AI (Minimax) ---
        
        // Piece Values
        const VALUES = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
        // Simplified position tables (flip for black)
        const PAWN_TABLE = [
            0,  0,  0,  0,  0,  0,  0,  0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
            5,  5, 10, 25, 25, 10,  5,  5,
            0,  0,  0, 20, 20,  0,  0,  0,
            5, -5,-10,  0,  0,-10, -5,  5,
            5, 10, 10,-20,-20, 10, 10,  5,
            0,  0,  0,  0,  0,  0,  0,  0
        ];
        const KNIGHT_TABLE = [
            -50,-40,-30,-30,-30,-30,-40,-50,
            -40,-20,  0,  0,  0,  0,-20,-40,
            -30,  0, 10, 15, 15, 10,  0,-30,
            -30,  5, 15, 20, 20, 15,  5,-30,
            -30,  0, 15, 20, 20, 15,  0,-30,
            -30,  5, 10, 15, 15, 10,  5,-30,
            -40,-20,  0,  5,  5,  0,-20,-40,
            -50,-40,-30,-30,-30,-30,-40,-50
        ];

        class AI {
            constructor(engine) {
                this.engine = engine;
            }

            evaluate() {
                let score = 0;
                for (let i = 0; i < 64; i++) {
                    const p = this.engine.board[i];
                    if (!p) continue;
                    
                    let val = VALUES[p.type];
                    
                    // Positional Score
                    let pScore = 0;
                    if (p.type === 'p') pScore = PAWN_TABLE[p.color === 'w' ? i : 63-i];
                    if (p.type === 'n') pScore = KNIGHT_TABLE[p.color === 'w' ? i : 63-i];

                    if (p.color === 'w') score += (val + pScore);
                    else score -= (val + pScore);
                }
                return score;
            }

            getBestMove(difficulty) {
                // Mapping difficulty 1-10 to Depth/Randomness
                // 1-2: Random legal
                // 3-5: Depth 2
                // 6-8: Depth 3
                // 9-10: Depth 3 + aggressive sort (not fully implemented here but implied by depth)
                
                const moves = this.engine.generateMoves('b', true);
                if (moves.length === 0) return null;

                if (difficulty <= 2) {
                    return moves[Math.floor(Math.random() * moves.length)];
                }

                const depth = difficulty <= 5 ? 2 : 3;
                let bestMove = null;
                let bestValue = -Infinity;
                let alpha = -Infinity;
                let beta = Infinity;

                // Simple move ordering: Captures first
                moves.sort((a, b) => (b.type === 'capture' ? 1 : 0) - (a.type === 'capture' ? 1 : 0));

                for (let move of moves) {
                    const state = this.engine.saveState();
                    this.engine.makeMove(move, true);
                    const boardValue = -this.minimax(depth - 1, -beta, -alpha, 'w'); // switch perspective
                    this.engine.restoreState(state);

                    if (boardValue > bestValue) {
                        bestValue = boardValue;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, bestValue);
                }
                return bestMove;
            }

            minimax(depth, alpha, beta, turn) {
                if (depth === 0) {
                    return turn === 'w' ? this.evaluate() : -this.evaluate();
                }

                const moves = this.engine.generateMoves(turn, true);
                if (moves.length === 0) return this.evaluate(); // or huge number if checkmate

                let bestValue = -Infinity;

                for (let move of moves) {
                    const state = this.engine.saveState();
                    this.engine.makeMove(move, true);
                    const val = -this.minimax(depth - 1, -beta, -alpha, turn === 'w' ? 'b' : 'w');
                    this.engine.restoreState(state);

                    bestValue = Math.max(bestValue, val);
                    alpha = Math.max(alpha, bestValue);
                    if (alpha >= beta) break;
                }
                return bestValue;
            }
        }

        // --- CONTROLLER & UI ---

        const game = new ChessEngine();
        const ai = new AI(game);
        
        let selectedSquare = -1;
        let validMoves = [];
        let difficulty = 5;
        let gameActive = false;
        let timerInterval = null;
        let secondsElapsed = 0;
        let isPaused = false;

        const boardEl = document.getElementById('board');
        const modal = document.getElementById('game-modal');
        const diffSlider = document.getElementById('difficulty-slider');
        const diffValue = document.getElementById('difficulty-value');
        const startBtn = document.getElementById('start-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const timerEl = document.getElementById('game-timer');
        const turnEl = document.getElementById('turn-indicator');
        const capturedWhiteEl = document.getElementById('captured-white');
        const capturedBlackEl = document.getElementById('captured-black');
        const toast = document.getElementById('toast');

        function renderBoard() {
            boardEl.innerHTML = '';
            for (let i = 0; i < 64; i++) {
                const sq = document.createElement('div');
                const row = Math.floor(i / 8);
                const col = i % 8;
                
                // Color
                const isLight = (row + col) % 2 === 0;
                sq.className = `relative w-full h-full flex items-center justify-center ${isLight ? 'square-light' : 'square-dark'}`;
                sq.dataset.index = i;

                // Piece
                const piece = game.board[i];
                if (piece) {
                    const pDiv = document.createElement('div');
                    // Removed specific w-5/6 h-5/6, relying on the .piece CSS class for better styling control
                    pDiv.className = 'piece pointer-events-none'; 
                    pDiv.innerHTML = PIECES[piece.color][piece.type];
                    sq.appendChild(pDiv);
                }

                // Interaction
                sq.onclick = () => handleSquareClick(i);

                // Highlights
                if (i === selectedSquare) sq.classList.add('square-selected');
                
                // Valid Move Hints
                const move = validMoves.find(m => m.to === i);
                if (move) {
                    if (game.board[i]) sq.classList.add('square-capture');
                    else sq.classList.add('square-valid-move');
                }

                boardEl.appendChild(sq);
            }
            
            // Updates info
            turnEl.innerText = game.turn === 'w' ? "White's Turn" : "Black's Turn";
            turnEl.className = `font-bold ${game.turn === 'w' ? 'text-white' : 'text-stone-400'}`;
        }

        function updateCapturedUI(color, pieceType) {
            const container = color === 'w' ? capturedBlackEl : capturedWhiteEl; // White captures go to Black list container (visual trophy room)
            // Wait, logic: Captured By White -> Shows Black pieces.
            // My container naming: 'captured-black' = captured pieces OF black color.
            
            const div = document.createElement('div');
            div.className = 'w-6 h-6';
            div.innerHTML = PIECES[color === 'w' ? 'b' : 'w'][pieceType]; // Render the captured piece
            container.appendChild(div);
        }

        function handleSquareClick(idx) {
            if (!gameActive || isPaused || game.turn !== 'w') return; // Only allow white (player) to click

            const piece = game.board[idx];

            // If clicking own piece, select it
            if (piece && piece.color === game.turn) {
                selectedSquare = idx;
                validMoves = game.generateMoves(game.turn, true).filter(m => m.from === idx);
                renderBoard();
                return;
            }

            // If clicking a valid move target
            const move = validMoves.find(m => m.to === idx);
            if (move) {
                // Check capture for UI
                if (game.board[move.to]) {
                    updateCapturedUI('w', game.board[move.to].type);
                }

                game.makeMove(move);
                selectedSquare = -1;
                validMoves = [];
                renderBoard();

                const status = game.checkStatus();
                if (status !== 'playing') endGame(status);
                else {
                    // AI Turn
                    setTimeout(aiMove, 500); // Small delay for realism
                }
            } else {
                // Deselect
                selectedSquare = -1;
                validMoves = [];
                renderBoard();
            }
        }

        function aiMove() {
            if (!gameActive) return;

            const move = ai.getBestMove(difficulty);
            if (move) {
                // Check capture for UI
                if (game.board[move.to]) {
                    updateCapturedUI('b', game.board[move.to].type);
                }

                game.makeMove(move);
                renderBoard();

                const status = game.checkStatus();
                if (status !== 'playing') endGame(status);
            } else {
                // Stalemate or Checkmate
                endGame(game.checkStatus());
            }
        }

        function startGame() {
            difficulty = parseInt(diffSlider.value);
            game.reset();
            gameActive = true;
            isPaused = false;
            secondsElapsed = 0;
            selectedSquare = -1;
            validMoves = [];
            
            capturedWhiteEl.innerHTML = '';
            capturedBlackEl.innerHTML = '';
            
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!isPaused) {
                    secondsElapsed++;
                    const m = Math.floor(secondsElapsed / 60).toString().padStart(2, '0');
                    const s = (secondsElapsed % 60).toString().padStart(2, '0');
                    timerEl.innerText = `${m}:${s}`;
                }
            }, 1000);

            toggleModal(false);
            renderBoard();
            showToast("Game Started! You are White.");
        }

        function togglePause() {
            if (!gameActive) return;
            isPaused = !isPaused;
            
            if (isPaused) {
                document.getElementById('modal-title').innerText = "Game Paused";
                document.getElementById('modal-subtitle').innerText = "Take a breather";
                startBtn.classList.add('hidden');
                resumeBtn.classList.remove('hidden');
                cancelBtn.classList.remove('hidden');
                toggleModal(true);
            } else {
                toggleModal(false);
            }
        }

        function endGame(status) {
            gameActive = false;
            clearInterval(timerInterval);
            let msg = "";
            if (status === 'checkmate') msg = game.turn === 'w' ? "Checkmate! Black Wins." : "Checkmate! You Win!";
            if (status === 'stalemate') msg = "Stalemate! It's a draw.";
            
            showToast(msg);
            
            setTimeout(() => {
                document.getElementById('modal-title').innerText = msg;
                document.getElementById('modal-subtitle').innerText = "Game Over";
                startBtn.innerText = "Play Again";
                startBtn.classList.remove('hidden');
                resumeBtn.classList.add('hidden');
                cancelBtn.classList.add('hidden');
                toggleModal(true);
            }, 1500);
        }

        function cancelGame() {
            gameActive = false;
            clearInterval(timerInterval);
            document.getElementById('modal-title').innerText = "Ultimate Chess Battle";
            document.getElementById('modal-subtitle').innerText = "Ready to play?";
            startBtn.innerText = "Start New Game";
            startBtn.classList.remove('hidden');
            resumeBtn.classList.add('hidden');
            cancelBtn.classList.add('hidden');
            isPaused = false;
            // Stay in modal
        }

        function toggleModal(show) {
            if (show) {
                modal.classList.remove('hidden-modal');
            } else {
                modal.classList.add('hidden-modal');
            }
        }

        function showToast(msg) {
            toast.innerText = msg;
            toast.classList.remove('translate-y-20');
            setTimeout(() => {
                toast.classList.add('translate-y-20');
            }, 3000);
        }

        // --- EVENTS ---
        
        diffSlider.oninput = (e) => diffValue.innerText = e.target.value;
        startBtn.onclick = startGame;
        resumeBtn.onclick = togglePause; // resumes
        cancelBtn.onclick = cancelGame;
        pauseBtn.onclick = togglePause;

        // Init
        renderBoard();

    </script>
</body>
</html>